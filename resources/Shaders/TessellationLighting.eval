#version 410 core

layout (triangles, equal_spacing, ccw) in;

uniform mat4 uVP;
uniform sampler2D uDisplacementMap;
uniform float uDisplacementFactor;

/* REMEMBER: The Tessellation Evaluation Shader can access the entire Tessellation Control Shader output patch. */
in vec3 worldPosition_es_in[];
in vec2 textureCoord_es_in[];
in vec3 normal_es_in[];

/* REMEMBER: The Tessellation Evaluation Shader always outputs a single vertex. (no array here) */
out vec3 worldPosition_fs_in;
out vec2 textureCoord_fs_in;
out vec3 normal_fs_in;

/* REMEMBER: gl_TessCoor.x, gl_TessCoor.y, gl_TessCoor.z are the barycentric coordinates of each vertex generated by the Primitive Generator.
 The Primitive Generator executes the Tessellation Evaluation Shader once for each generated vertex */
vec2 interpolate2D(vec2 pV0, vec2 pV1, vec2 pV2)
{
    return vec2(gl_TessCoord.x) * pV0 + vec2(gl_TessCoord.y) * pV1 + vec2(gl_TessCoord.z) * pV2;
}

vec3 interpolate3D(vec3 pV0, vec3 pV1, vec3 pV2)
{
    return vec3(gl_TessCoord.x) * pV0 + vec3(gl_TessCoord.y) * pV1 + vec3(gl_TessCoord.z) * pV2;
}

/* Tessellation evaluation shader runs on each barycentric coordinates generated by the Primitive generator */
void main()
{
    /* Interpolate the attributes of the output vertex using barycentric coordinates */
    textureCoord_fs_in = interpolate2D(textureCoord_es_in[0], textureCoord_es_in[1], textureCoord_es_in[2]);
    normal_fs_in = interpolate3D(normal_es_in[0], normal_es_in[1], normal_es_in[2]);
    normal_fs_in = normalize(normal_fs_in);
    worldPosition_fs_in = interpolate3D(worldPosition_es_in[0], worldPosition_es_in[1], worldPosition_es_in[2]);

    /* Translate the vertex along the normal from the normal map */
    float lTranslation = texture(uDisplacementMap, textureCoord_fs_in.xy).x;
    worldPosition_fs_in += normal_fs_in * lTranslation * uDisplacementFactor;

    gl_Position = uVP * vec4(worldPosition_fs_in, 1.0f);
}
